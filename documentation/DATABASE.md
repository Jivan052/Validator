# ValidateIt - Database Structure Documentation

This document outlines the database structure used in ValidateIt, including collections, document schemas, relationships, and best practices for working with Firestore.

## Database Overview

ValidateIt uses Firebase Firestore, a NoSQL document database, to store all application data. The database is structured around two primary collections:

1. `users`: Stores user information and usage metrics
2. `ideas`: Stores business ideas and their associated analyses

## Collection: users

The `users` collection stores information about application users and their usage metrics.

### Document Schema

Each document in the `users` collection represents a single user and has the following structure:

```javascript
{
  // User metadata
  "createdAt": Timestamp,        // When the user document was first created
  "updatedAt": Timestamp,        // When the user document was last updated
  
  // Usage metrics
  "questionCount": Number,       // Total count of questions asked (including initial ideas and follow-ups)
  
  // Additional fields can be added as needed for user preferences, subscription status, etc.
}
```

### Document ID

Document IDs in the `users` collection correspond to the Firebase Authentication UID for each user. This allows for easy access control and user-specific operations.

Example document path: `users/G3iD5Ek9P2hJfLmQrSt7XvZy1A`

## Collection: ideas

The `ideas` collection stores business ideas submitted by users and their associated analyses.

### Document Schema

Each document in the `ideas` collection represents a single business idea and has the following structure:

```javascript
{
  // Ownership and metadata
  "userId": String,              // Reference to the user who created the idea
  "createdAt": Timestamp,        // When the idea was first created
  "updatedAt": Timestamp,        // When the idea was last updated
  
  // Idea content
  "ideaText": String,            // The original business idea description
  "keywords": Array<String>,     // Keywords extracted from the idea
  
  // Status tracking
  "status": String,              // "processing", "completed", or "error"
  
  // Analysis results (present after analysis is completed)
  "newsArticles": [              // Related news articles
    {
      "title": String,
      "description": String,
      "url": String,
      "urlToImage": String,
      "publishedAt": String,
      "source": {
        "id": String,
        "name": String
      }
    }
  ],
  
  "analysis": {
    "summary": String,           // Executive summary of the idea
    "marketPotential": {         // Market opportunity assessment
      "score": Number,           // Score from 1-10
      "explanation": String      // Textual explanation of the score
    },
    "keyTrends": [               // Current market trends
      {
        "trend": String,
        "impact": String         // "positive", "negative", or "neutral"
      }
    ],
    "sentiment": {               // Overall sentiment analysis
      "positive": Number,        // Percentage (0-100)
      "neutral": Number,         // Percentage (0-100)
      "negative": Number         // Percentage (0-100)
    },
    "riskFactors": {             // Risk assessment by category
      "market": Number,          // Score from 1-10
      "technical": Number,       // Score from 1-10
      "financial": Number,       // Score from 1-10
      "regulatory": Number       // Score from 1-10
    },
    "swot": {                    // SWOT analysis
      "strengths": Array<String>,
      "weaknesses": Array<String>,
      "opportunities": Array<String>,
      "threats": Array<String>
    },
    "executionSteps": [          // Recommended implementation steps
      {
        "phase": String,
        "duration": String,
        "description": String
      }
    ],
    "timeToMarket": {            // Time to market estimation
      "months": Number,
      "explanation": String
    },
    "competitors": [             // Potential competitors
      {
        "name": String,
        "strength": String       // "major", "minor", or "indirect"
      }
    ]
  },
  
  // Follow-up questions and answers
  "questions": [
    {
      "question": String,        // The follow-up question asked
      "answer": String,          // The AI-generated answer
      "timestamp": Date          // When the Q&A occurred (JavaScript Date object)
    }
  ]
}
```

### Document ID

Document IDs in the `ideas` collection are auto-generated by Firestore when a new idea is created.

Example document path: `ideas/1a2b3c4d5e6f7g8h9i0j`

## Database Relationships

ValidateIt uses the following relationships between collections:

1. **User-to-Ideas Relationship**:
   - One-to-many relationship (one user can have multiple ideas)
   - Implemented using the `userId` field in the `ideas` collection
   - To query a user's ideas: `collection('ideas').where('userId', '==', currentUser.uid)`

## Security Rules

The following Firestore security rules are implemented to protect data:

```
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Ideas can only be read or written by their owner
    match /ideas/{ideaId} {
      allow read, write: if request.auth != null && request.auth.uid == resource.data.userId;
    }
    
    // User documents can only be read or written by the corresponding user
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
  }
}
```

## Working with Firestore Timestamps

### Server Timestamps

Server timestamps (`serverTimestamp()`) are used to ensure consistent timestamp values across devices. However, they have some limitations:

- They can only be used at the document's root level or in nested objects
- They cannot be used directly inside arrays (see FIRESTORE_TIMESTAMPS.md)

For timestamps inside arrays (like in the `questions` array), JavaScript `Date` objects are used instead.

### Example:

```javascript
// For root-level timestamps, use serverTimestamp()
await addDoc(collection(db, IDEAS_COLLECTION), {
  userId,
  ideaText,
  keywords,
  createdAt: serverTimestamp(),
  updatedAt: serverTimestamp(),
});

// For timestamps in arrays, use JavaScript Date objects
questions.push({
  question,
  answer,
  timestamp: new Date(),
});
```

## Query Patterns

### Common Query Patterns

1. **Get a User's Ideas**:
   ```javascript
   const q = query(
     collection(db, 'ideas'),
     where("userId", "==", userId),
     orderBy("createdAt", "desc")
   );
   const querySnapshot = await getDocs(q);
   ```

2. **Get a Single Idea by ID**:
   ```javascript
   const docRef = doc(db, 'ideas', ideaId);
   const docSnap = await getDoc(docRef);
   ```

3. **Get a User's Question Count**:
   ```javascript
   const userRef = doc(db, 'users', userId);
   const userDoc = await getDoc(userRef);
   const count = userDoc.exists() ? userDoc.data().questionCount : 0;
   ```

## Performance Optimization

ValidateIt implements several strategies to optimize Firestore performance:

1. **Client-Side Caching**:
   - Question counts are cached with a 2-hour expiration
   - Cache is updated immediately on user actions for responsive UI
   - Cache falls back gracefully on errors

2. **Batched Updates**:
   - Multiple question count increments within a short period are batched
   - Implementation uses a 2-second window for batching
   - Reduces write operations for frequent follow-up questions

3. **Optimized Reads**:
   - Limiting query results with appropriate constraints
   - Using cached data when possible to avoid unnecessary reads

4. **Efficient Error Handling**:
   - Falling back to cached data when network errors occur
   - Providing graceful degradation when Firestore is unavailable

## Data Migration Considerations

When migrating or updating the database structure, consider the following:

1. **Version Fields**: Add version fields to documents to track schema versions
2. **Incremental Updates**: Update documents incrementally rather than all at once
3. **Default Values**: Include default values for new fields to handle existing documents
4. **Backwards Compatibility**: Ensure code handles both old and new document structures

## Data Backup Strategy

Recommended backup strategy for ValidateIt data:

1. **Regular Firestore Exports**: Schedule regular exports to Google Cloud Storage
2. **Point-in-Time Recovery**: Enable Firestore point-in-time recovery
3. **Application-Level Backups**: Implement critical data export functionality
4. **User Data Portability**: Allow users to export their own ideas and analyses

## Best Practices

1. **Denormalization**: Firestore performs best with denormalized data models
2. **Document Size**: Keep documents under 1MB in size
3. **Shallow Queries**: Design queries to be shallow rather than deep
4. **Index Planning**: Create composite indexes for common queries
5. **Batch Operations**: Use batch operations for multiple writes
6. **Offline Support**: Leverage Firestore's offline capabilities for better UX
7. **Security Rules Testing**: Thoroughly test security rules before deployment